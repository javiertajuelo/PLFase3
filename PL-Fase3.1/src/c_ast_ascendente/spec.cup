package asint;

import java_cup.runtime.*;
import asint.ClaseSemanticaEval;
import asint.SintaxisAbstractaEval.*;
import c_ast_ascendente.UnidadLexica.StringLocalizado;


scan with {: 
  return getScanner().next_token(); 
:};

parser code {:
   private GestionErroresEval errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};

init with {:
   errores = new GestionErroresEval();
   AnalizadorLexicoEval alex = (AnalizadorLexicoEval)getScanner();
   alex.fijaGestionErrores(errores);
:};

action code {:
  ClaseSemanticaEval sem = new ClaseSemanticaEval();
:};


terminal 
    IF, ELSE, WHILE, READ, WRITE, NEW, DELETE, CALL, NL, 
    TRUE, FALSE, NULL, STRUCT, PROC, TYPE, EVAL, AND, OR, NOT,
    INT, REAL, BOOL, STRING, 
    MAS, MENOS, POR, DIV, MOD, 
    MENOR, MAYOR, MENIGUAL, MAYIGUAL, IGUAL, DISTINTO, 
    ASIGNACION, PAP, PCIERRE, CORAP, CORCIERRE, LLAVEAP, LLAVECIERRE,
    PUNTOYCOMA, COMA, PUNTO, PUNTERO, REFERENCIA, FINDECL;
    
terminal StringLocalizado IDEN, LIT_ENT, LIT_REAL, LIT_CADENA;

 mal
non terminal Prog programa;
non terminal DeclaracionesConSep DeclaracionesConSeparador ;
non terminal LDecs          lista_declaraciones;
non terminal Declaracion    declaracion;
non terminal Tipo           tipo0, tipo1, tipo2;
non terminal Exp            lista_parametros, parametros, parametro;
non terminal Exp            lista_instrucciones, instrucciones, instruccion, else_opt;
non terminal Exp            lista_argumentos, argumentos;
non terminal Exp            ExpresionAsignacion, ExpresionRelacional, ExpresionAditiva,
                           ExpresionLogica, ExpresionMultiplicativa, ExpresionUnaria,
                           ExpresionAcceso, Factor;
non terminal String         OperadorRelacional, OperadorMultiplicativo, OperadorUnario;

/*-------------------------*/
/* Producciones según la especificación */
/*-------------------------*/

/* Programa → { DeclaracionesConSeparador ListaInstrucciones }
   Programa.a = prog(DeclaracionesConSeparador.a, ListaInstrucciones.a)
*/
programa ::= "{" DeclaracionesConSeparador:ds lista_instrucciones:li "}"
    {: RESULT = sem.prog(ds, li); :};

/* DeclaracionesConSeparador → Declaraciones &&  
   DeclaracionesConSeparador.a = declaraciones_con_separador(Declaraciones.a)
   | ε  
   DeclaracionesConSeparador.a = sin_declaraciones()
*/
DeclaracionesConSeparador ::= declaraciones:ds "&&"
    {: RESULT = sem.declaraciones_con_separador(ds); :}
  |  
    {: RESULT = sem.sin_declaraciones(); :};

/* Declaraciones → Declaraciones ; Declaración  
   Declaraciones0.a = muchas_declaraciones(Declaraciones1.a, Declaración.a)
   | Declaración  
   Declaraciones.a = una_dec(Declaración.a)
*/
declaraciones ::= declaraciones:ds FINDECL declaracion:d
    {: RESULT = sem.muchas_decs(ds, d); :}
  | declaracion:d
    {: RESULT = sem.una_dec(d); :};

/* Declaración → Tipo0 identificador  
   Declaración.a = declaracion_tipo(Tipo0.a, identificador.lex)
   | type Tipo0 identificador  
   Declaración.a = declaracion_tipo(Tipo0.a, identificador.lex)
   | proc identificador ( ListaParametros ) Programa  
   Declaración.a = declaracion_proc(identificador.lex, ListaParametros.a, Programa.a)
*/
declaracion ::= tipo0:t IDEN:id
    {: RESULT = sem.declaracion_tipo(t, id.str()); :}
  | TYPE tipo0:t IDEN:id
    {: RESULT = sem.declaracion_tipo(t, id.str()); :}
  | PROC IDEN:id "(" lista_parametros:lp ")" programa:p
    {: RESULT = sem.declaracion_proc(id.str(), lp, p); :};

/* Tipo0 → Tipo0 [literalEntero]  
   Tipo0.a = tipo_array(Tipo0.a, literalEntero.lex)
   | Tipo1  
   Tipo0.a = Tipo1.a
*/
tipo0 ::= tipo0:t LIT_ENT:ent
    {: RESULT = sem.tipo_array(t, ent.str()); :}
  | tipo1:t
    {: RESULT = t; :};

/* Tipo1 → ^Tipo1  
   Tipo1.a = tipo_puntero(Tipo1.a)
   | Tipo2  
   Tipo1.a = Tipo2.a
*/
tipo1 ::= "^" tipo1:t
    {: RESULT = sem.tipo_puntero(t); :}
  | tipo2:t
    {: RESULT = t; :};

/* Tipo2 → int  
   Tipo2.a = tipo_int()
   | real  
   Tipo2.a = tipo_real()
   | bool  
   Tipo2.a = tipo_bool()
   | string  
   Tipo2.a = tipo_string()
   | struct { Campos }  
   Tipo2.a = tipo_struct(Campos.a)
   | identificador  
   Tipo2.a = tipo_iden(identificador.lex)
*/
tipo2 ::= INT
    {: RESULT = sem.tipo_int(); :}
  | REAL
    {: RESULT = sem.tipo_real(); :}
  | BOOL
    {: RESULT = sem.tipo_bool(); :}
  | STRING
    {: RESULT = sem.tipo_string(); :}
  | STRUCT "{" Campos:c "}"
    {: RESULT = sem.tipo_struct(c); :}
  | IDEN:id
    {: RESULT = sem.tipo_iden(id.str()); :};

/* Campos → Campos , Declaración  
   Campos0.a = muchos_campos(Campos1.a, Declaración.a)
   | Declaración  
   Campos.a = un_campo(Declaración.a)
*/
Campos ::= Campos:c COMA declaracion:d
    {: RESULT = sem.muchos_campos(c, d); :}
  | declaracion:d
    {: RESULT = sem.un_campo(d); :};

/* ListaParametros → Parametros  
   ListaParametros.a = lista_parametros(Parametros.a)
   | ε  
   ListaParametros.a = sin_parametros()
*/
lista_parametros ::= parametros:p
    {: RESULT = sem.lista_parametros(p); :}
  |
    {: RESULT = sem.sin_parametros(); :};

/* Parametros → Parametros , Parametro  
   Parametros0.a = muchos_parametros(Parametros1.a, Parametro.a)
   | Parametro  
   Parametros.a = un_parametro(Parametro.a)
*/
parametros ::= parametros:p COMA parametro:par
    {: RESULT = sem.muchos_parametros(p, par); :}
  | parametro:par
    {: RESULT = sem.un_parametro(par); :};

/* Parametro → Tipo0 identificador  
   Parametro.a = parametro(Tipo0.a, identificador.lex)
   | Tipo0 & identificador  
   Parametro.a = parametro_referencia(Tipo0.a, identificador.lex)
*/
parametro ::= tipo0:t IDEN:id
    {: RESULT = sem.parametro(t, id.str()); :}
  | tipo0:t AMPERSAND IDEN:id
    {: RESULT = sem.parametro_referencia(t, id.str()); :};

/* ListaInstrucciones → Instrucciones  
   ListaInstrucciones.a = lista_instrucciones(Instrucciones.a)
   | ε  
   ListaInstrucciones.a = sin_instrucciones()
*/
lista_instrucciones ::= instrucciones:ins
    {: RESULT = sem.lista_instrucciones(ins); :}
  |
    {: RESULT = sem.sin_instrucciones(); :};

/* Instrucciones → Instrucciones ; Instrucción  
   Instrucciones0.a = muchas_instrucciones(Instrucciones1.a, Instrucción.a)
   | Instrucción  
   Instrucciones.a = una_instruccion(Instrucción.a)
*/
instrucciones ::= instrucciones:ins FINDECL instruccion:inst
    {: RESULT = sem.muchas_instrucciones(ins, inst); :}
  | instruccion:inst
    {: RESULT = sem.una_instruccion(inst); :};

/* Instrucción → eval ExpresionAsignacion  
   Instrucción.a = instruccion_eval(ExpresionAsignacion.a)
   | if ExpresionAsignacion Programa ElseOpt  
   Instrucción.a = instruccion_if(ExpresionAsignacion.a, Programa.a, ElseOpt.a)
   | while ExpresionAsignacion Programa  
   Instrucción.a = instruccion_while(ExpresionAsignacion.a, Programa.a)
   | read ExpresionAsignacion  
   Instrucción.a = instruccion_read(ExpresionAsignacion.a)
   | write ExpresionAsignacion  
   Instrucción.a = instruccion_write(ExpresionAsignacion.a)
   | nl  
   Instrucción.a = instruccion_nl()
   | new ExpresionAsignacion  
   Instrucción.a = instruccion_new(ExpresionAsignacion.a)
   | delete ExpresionAsignacion  
   Instrucción.a = instruccion_delete(ExpresionAsignacion.a)
   | call identificador ( ListaArgumentos )  
   Instrucción.a = instruccion_call(identificador.lex, ListaArgumentos.a)
   | Programa  
   Instrucción.a = instruccion_programa(Programa.a)
*/
instruccion ::= EVAL ExpresionAsignacion:ea
    {: RESULT = sem.instruccion_eval(ea); :}
  | IF ExpresionAsignacion:ea programa:p else_opt:eo
    {: RESULT = sem.instruccion_if(ea, p, eo); :}
  | WHILE ExpresionAsignacion:ea programa:p
    {: RESULT = sem.instruccion_while(ea, p); :}
  | READ ExpresionAsignacion:ea
    {: RESULT = sem.instruccion_read(ea); :}
  | WRITE ExpresionAsignacion:ea
    {: RESULT = sem.instruccion_write(ea); :}
  | NL
    {: RESULT = sem.instruccion_nl(); :}
  | NEW ExpresionAsignacion:ea
    {: RESULT = sem.instruccion_new(ea); :}
  | DELETE ExpresionAsignacion:ea
    {: RESULT = sem.instruccion_delete(ea); :}
  | CALL IDEN:id "(" ListaArgumentos:la ")"
    {: RESULT = sem.instruccion_call(id.str(), la); :}
  | programa:p
    {: RESULT = sem.instruccion_programa(p); :};

/* ElseOpt → else Programa  
   ElseOpt.a = else_opt_else(Programa.a)
   | ε  
   ElseOpt.a = else_opt_vacio()
*/
else_opt ::= ELSE programa:p
    {: RESULT = sem.else_opt_else(p); :}
  | 
    {: RESULT = sem.else_opt_vacio(); :};

/* ListaArgumentos → Argumentos  
   ListaArgumentos.a = lista_argumentos(Argumentos.a)
   | ε  
   ListaArgumentos.a = sin_argumentos()
*/
lista_argumentos ::= argumentos:a
    {: RESULT = sem.lista_argumentos(a); :}
  | 
    {: RESULT = sem.sin_argumentos(); :};

/* Argumentos → Argumentos , ExpresionAsignacion  
   Argumentos0.a = muchos_argumentos(Argumentos1.a, ExpresionAsignacion.a)
   | ExpresionAsignacion  
   Argumentos.a = un_argumento(ExpresionAsignacion.a)
*/
argumentos ::= argumentos:a COMA ExpresionAsignacion:ea
    {: RESULT = sem.muchos_argumentos(a, ea); :}
  | ExpresionAsignacion:ea
    {: RESULT = sem.un_argumento(ea); :};

/* ExpresionAsignacion → ExpresionRelacional = ExpresionAsignacion  
   ExpresionAsignacion.a = expresion_asignacion(ExpresionRelacional.a, ExpresionAsignacion.a)
   | ExpresionRelacional  
   ExpresionAsignacion.a = ExpresionRelacional.a
*/
ExpresionAsignacion ::= ExpresionRelacional:er "=" ExpresionAsignacion:ea
    {: RESULT = sem.expresion_asignacion(er, ea); :}
  | ExpresionRelacional:er
    {: RESULT = er; :};

/* ExpresionRelacional → ExpresionRelacional OperadorRelacional ExpresionAditiva  
   ExpresionRelacional0.a = mkop(OperadorRelacional, ExpresionRelacional1.a, ExpresionAditiva.a)
   | ExpresionAditiva  
   ExpresionRelacional.a = ExpresionAditiva.a
*/
ExpresionRelacional ::= ExpresionRelacional:er OperadorRelacional:op ExpresionAditiva:ea
    {: RESULT = sem.mkop(op, er, ea); :}
  | ExpresionAditiva:ea
    {: RESULT = ea; :};

/* ExpresionAditiva → ExpresionAditiva + ExpresionLogica  
   ExpresionAditiva0.a = mkop("+", ExpresionAditiva1.a, ExpresionLogica.a)
   | ExpresionAditiva → ExpresionLogica - ExpresionLogica  
   ExpresionAditiva.a = mkop("-", ExpresionLogica0.a, ExpresionLogica1.a)
   | ExpresionAditiva.a = ExpresionLogica.a
*/
ExpresionAditiva ::= ExpresionAditiva:ea "+" ExpresionLogica:el
    {: RESULT = sem.mkop("+", ea, el); :}
  | ExpresionAditiva:ea "-" ExpresionLogica:el
    {: RESULT = sem.mkop("-", ea, el); :}
  | ExpresionLogica:el
    {: RESULT = el; :};

/* ExpresionLogica → ExpresionMultiplicativa and ExpresionLogica  
   ExpresionLogica0.a = mkop("and", ExpresionMultiplicativa.a, ExpresionLogica1.a)
   | ExpresionLogica → ExpresionMultiplicativa or ExpresionMultiplicativa  
   ExpresionLogica.a = mkop("or", ExpresionMultiplicativa0.a, ExpresionMultiplicativa1.a)
   | ExpresionLogica.a = ExpresionMultiplicativa.a
*/
ExpresionLogica ::= ExpresionMultiplicativa:em "and" ExpresionLogica:el
    {: RESULT = sem.mkop("and", em, el); :}
  | ExpresionMultiplicativa:em "or" ExpresionMultiplicativa:em2
    {: RESULT = sem.mkop("or", em, em2); :}
  | ExpresionMultiplicativa:em
    {: RESULT = em; :};

/* ExpresionMultiplicativa → ExpresionMultiplicativa OperadorMultiplicativo ExpresionUnaria  
   ExpresionMultiplicativa0.a = mkop(OperadorMultiplicativo, ExpresionMultiplicativa1.a, ExpresionUnaria.a)
   | ExpresionMultiplicativa.a = ExpresionUnaria.a
*/
ExpresionMultiplicativa ::= ExpresionMultiplicativa:em OperadorMultiplicativo:op ExpresionUnaria:eu
    {: RESULT = sem.mkop(op, em, eu); :}
  | ExpresionUnaria:eu
    {: RESULT = eu; :};

/* ExpresionUnaria → OperadorUnario ExpresionUnaria  
   ExpresionUnaria0.a = mkop(OperadorUnario, ExpresionUnaria1.a, null)
   | ExpresionUnaria.a = ExpresionAcceso.a
*/
ExpresionUnaria ::= OperadorUnario:op ExpresionUnaria:eu
    {: RESULT = sem.mkop(op, eu, null); :}
  | ExpresionAcceso:ea
    {: RESULT = ea; :};

/* ExpresionAcceso → ExpresionAcceso [ ExpresionAsignacion ]  
   ExpresionAcceso0.a = expresion_acceso_array(ExpresionAcceso1.a, ExpresionAsignacion.a)
   | ExpresionAcceso → ExpresionAcceso . identificador  
   ExpresionAcceso.a = expresion_acceso_punto(ExpresionAcceso.a, identificador.lex)
   | ExpresionAcceso → ExpresionAcceso ^  
   ExpresionAcceso.a = expresion_acceso_puntero(ExpresionAcceso.a)
   | ExpresionAcceso.a = Factor.a
*/
ExpresionAcceso ::= ExpresionAcceso:ea "[" ExpresionAsignacion:ex "]"
    {: RESULT = sem.expresion_acceso_array(ea, ex); :}
  | ExpresionAcceso:ea "." IDEN:id
    {: RESULT = sem.expresion_acceso_punto(ea, id.str()); :}
  | ExpresionAcceso:ea "^"
    {: RESULT = sem.expresion_acceso_puntero(ea); :}
  | Factor:f
    {: RESULT = f; :};

/* Factor → ( ExpresionAsignacion )  
   | LiteralEntero  
   | LiteralReal  
   | LiteralBool  
   | LiteralCadena  
   | null  
   | identificador  
   (se usan los tokens LIT_ENT, LIT_REAL, etc.)
*/
Factor ::= "(" ExpresionAsignacion:ea ")"
    {: RESULT = ea; :}
  | LIT_ENT:ent
    {: RESULT = sem.factor_literal_entero(ent.str()); :}
  | LIT_REAL:rl
    {: RESULT = sem.factor_literal_real(rl.str()); :}
  | LIT_CADENA:lc
    {: RESULT = sem.factor_literal_cadena(lc.str()); :}
  | "null"
    {: RESULT = sem.factor_null(); :}
  | IDEN:id
    {: RESULT = sem.factor_identificador(id.str()); :};

/* OperadorMultiplicativo → *  
   OperadorMultiplicativo.op = "*"
   | /  
   OperadorMultiplicativo.op = "/"
*/
OperadorMultiplicativo ::= "*" 
    {: RESULT = "*"; :}
  | "/" 
    {: RESULT = "/"; :};

/* OperadorUnario → not  
   OperadorUnario.op = "not"
   | -  
   OperadorUnario.op = "-"
*/
OperadorUnario ::= "not"
    {: RESULT = "not"; :}
  | "-" 
    {: RESULT = "-"; :};

/* OperadorRelacional → <  
   OperadorRelacional.op = "<"
   | >  
   OperadorRelacional.op = ">"
   | <=  
   OperadorRelacional.op = "<="
   | >=  
   OperadorRelacional.op = ">="
   | ==  
   OperadorRelacional.op = "=="
   | !=  
   OperadorRelacional.op = "!="
*/
OperadorRelacional ::= "<"
    {: RESULT = "<"; :}
  | ">"
    {: RESULT = ">"; :}
  | "<="
    {: RESULT = "<="; :}
  | ">="
    {: RESULT = ">="; :}
  | "=="
    {: RESULT = "=="; :}
  | "!="
    {: RESULT = "!="; :};


